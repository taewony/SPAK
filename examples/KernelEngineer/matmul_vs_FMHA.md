MatMul과 FMHA를 시스템 엔지니어링의 **SUT(System Under Test)** 관점에서 분석하면, 두 시스템의 설계 목표, 복잡도 및 특성이 명확히 대비됩니다. 아래 표가 핵심 차이를 보여줍니다.

| 시스템 특성 | **MatMul (배치 처리 포함)** | **Fused Multi-Head Attention (FMHA)** |
| :--- | :--- | :--- |
| **시스템 경계** | 단일, 명확한 수학 연산 모듈 | 복합적, 데이터흐름과 제어 흐름이 결합된 파이프라인 |
| **핵심 기능** | 선형 변환 (Linear Transformation) | **시퀀스 정보의 맥락적 가중 합** (Context-Weighted Aggregation) |
| **수학적 본질** | **Bilinear Operation** (쌍선형 연산) | **Conditional Nonlinear Transformation** (조건부 비선형 변환) |
| **Einsum 표현** | 단일, 정적: `"bik,bkj->bij"` | **다중, 동적 의존성** 포함: `softmax("bihd,bjhd->bhij") * "bjhd->bihd"` |
| **내부 상태** | **무상태(Stateless)**: 입력만으로 출력이 결정됨 | **상태 유사(Stateful)**: Online Softmax로 인해 처리 순서에 의존적 |
| **최적화 초점** | **산술 연산량(FLOPs) 최소화**, 메모리 접근 최적화 | **메모리 지연 시간(Latency) 숨기기**, 데이터 이동 최소화(Fusion) |
| **병렬화 전략** | 데이터 병렬 (배치, 행, 열) | **Hybrid 병렬** (배치/헤드, 시퀀스-타일, 채원 차원) |
| **시스템 테스트 기준** | 수치 정확도 (Numerical Accuracy) | **정확도 + 처리량(Throughput) + 지연 시간(Latency)** |

### 🔷 MatMul 시스템: “정적 변환기(Static Transformer)”

MatMul 시스템은 **명확하고 폐쇄된(closed-form) 수학적 변환**을 수행합니다.

*   **수학적 특성화**: `Output = f(A, B) = A @ B`. `f`는 **결합적**이며 **분배법칙**이 성립하는 완전한 선형 연산입니다.
*   **시스템 경계**: 입력 텐서 `A`, `B`와 출력 텐서 `C` 사이의 경계가 명확합니다. 내부에는 숨겨진 상태나 조건부 로직이 없습니다.
*   **Einsum 요약 가능성**: **완벽하게 요약 가능**합니다. `"bik,bkj->bij"`라는 하나의 식이 배치, 타일링, 병렬화를 포함한 **모든 구현의 정확한 의미를 정의**합니다. 구현은 단지 이 수학적 사상을 하드웨어에 효율적으로 매핑하는 방법의 차이일 뿐입니다.

### 🔶 FMHA 시스템: “동적 컨텍스트 프로세서(Dynamic Context Processor)”

FMHA 시스템은 **데이터 의존적이고 비선형적인** 변환을 통해 **시퀀스의 맥락(Context)** 을 계산합니다.

*   **수학적 특성화**: `Output = g(Q, K, V) = Softmax( (Q @ K^T) / sqrt(d_k) + M ) @ V`.
    *   `g`는 **비선형(Softmax)** 과 **선형(MatMul)** 의 합성 함수입니다.
    *   `M` (마스크)의 존재로 인해 **조건부(Conditional)** 연산이 도입됩니다.
    *   Online Softmax 사용 시, **처리 순서**에 따라 중간 상태(`m_i`, `l_i`)가 진화하는 **유사 상태(Stateful)** 시스템이 됩니다.
*   **시스템 경계**: 단일 수식 이상입니다. **QK 연산, 마스킹, 스케일링, 소프트맥스 정규화, PV 연산**이라는 여러 하위 시스템의 **파이프라인**으로 구성됩니다. 각 하위 시스템 간 데이터 흐름과 메모리 할당이 시스템 경계의 핵심입니다.
*   **Einsum 요약의 한계**: 기본 개념은 `"b h q d, b h k d -> b h q d"`로 나타낼 수 있으나, 이는 **기능적 의미만을 기술**할 뿐, FMHA의 핵심인 **연산 순서, 중간 데이터 관리, 메모리 퓨전 등의 시스템적 복잡성을 전혀 담아내지 못합니다**. FMHA의 “시스템”은 성능을 위한 **메모리 액세스 패턴과 실행 스케줄의 최적화** 그 자체입니다.

### 📈 단순 Attention에서 FMHA로의 시스템 진화

아래 진화 과정은 **수학적 동등성을 유지하면서 시스템 설계가 어떻게 복잡성을 키워 성능을 극대화하는지** 보여줍니다.

| 단계 | 시스템 명 | 핵심 수학/시스템 특성 | 시스템 복잡도 추가 요소 |
| :--- | :--- | :--- | :--- |
| **1** | **Naive Attention** | `O = softmax(QK^T/s) V`<br>**명시적 중간 행렬**: `S=QK^T`, `P=softmax(S)` | 낮음. **Global Softmax**로 인한 대규모 중간 메모리(`S`, `P`) 필요. |
| **2** | **Fused Attention** | `O = OnlineSoftmax_Tiled(QK^T/s) @ V`<br>**상태 변수 도입**: `m_i`, `l_i` | 중간. **Online Softmax**로 중간 저장소 제거. **타일 기반 루프**로 메모리 계층 활용. |
| **3** | **Fused Multi-Head (FMHA)** | `O_h = OnlineSoftmax_Tiled(Q_h K_{g(h)}^T/s + M) @ V_{g(h)}`<br>**다차원 병렬화**: 배치(B), 헤드(H), 시퀀스 타일(M,N) | 높음. **Multi-Head/GQA 병렬화**, **Causal Masking** 통합, **Autotuning**으로 하드웨어 변동성 대응. |

**진화의 핵심**: Naive Attention의 **수학적 정의**에서 출발하여, Fused Attention은 **메모리子系统**을 재설계하고, FMHA는 **실행子系统(스케줄러)** 를 추가하여 **전체 시스템의 처리량(Throughput)과 지연 시간(Latency)을 최적화**합니다.

### 💎 결론: 수학적 사상 vs. 시스템 구현

*   **MatMul**은 **수학적 사상이 구현을 완전히 지배**하는 시스템입니다. 모든 최적화는 이 단일 연산을 더 빠르게 실행하기 위한 방법론일 뿐입니다.
*   **FMHA**는 **성능 목표가 구현 구조를 지배**하는 시스템입니다. 동일한 수학적 사상을 만족시키는 무수히 많은 구현 경로 중, **메모리 대역폭, 캐시 효율, 연산 밀도, 하드웨어 변동성**을 종합적으로 고려하여 선택된 하나의 특정 “**실행 계획**”이 바로 FMHA 시스템입니다.

따라서 MatMul을 `y = f(x)` 같은 순수 함수로 볼 수 있다면, FMHA는 성능이라는 제약 조건 하에서 `y ≈ f(x)`를 달성하는 **복잡한 실시간 처리 파이프라인**으로 바라보는 것이 적절합니다. 이것이 FMHA가 단일 einsum으로 요약되기 어려운 시스템적 복잡성의 본질입니다.