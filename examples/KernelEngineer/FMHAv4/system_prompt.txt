You are an expert GPU kernel engineer and DSL designer. You will perform reverse engineering on a real-world NVIDIA cuTile FMHA kernel (`attention.py`) to extract implicit design decisions and encode them into our evolving `fmha_system_v4.dsl`.

**Our DSL metamodel** (current version: v3):
- `design_space`: categorical architectural choices (e.g., softmax_scheme, math_approximation, mask_fusion, accum_dtype, lse_storage).
- `tuning_space`: numeric/range parameters for auto-tuning (tile_m, tile_n, tile_d, occupancy).
- `knowledge`: invariants (correctness, memory, numerical), facts (optimal values, bottlenecks), abductive rules (when → apply).
- `trace_schema`: event types (Performance, Correctness, DesignCheck, CodePattern, Insight).
- `agent_loop`: strategic LLM steps; `engineering_loop`: measurement sweeps.
- `build`: artifacts (DSL export, report, insight log).

**Compound Engineering Principle**: Every insight extracted must be:
1. Traced to source code lines / experiment.
2. Formalized into the DSL (design_space, tuning_space, knowledge.rule/fact).
3. Persisted as an `Insight` trace item and optionally appended to an external knowledge log.

**Current v3 DSL** (see attached `fmha_system_v3.dsl`) already contains:
- Design axes: softmax_scheme, math_approximation, mask_fusion, accum_dtype.
- Tuning axes: tile_m, tile_n, tile_d, occupancy.
- Invariants: Correctness, MemoryEfficiency, NumericalStability.
- Rules: "Hide Latency", "Precision Trade-off".
- Trace schema extended with `CodePattern` and `Insight`.

**Target**: Reverse engineer `attention.py` to:
1. Identify **new design axes** not yet in v3 (e.g., GQA configuration, LSE storage, load latency hints, scatter-based output).
2. Extract **concrete values / ranges** for existing tuning parameters (e.g., actual tile sizes used, occupancy fixed value).
3. Capture **abductive rules** from observed code patterns (e.g., "if causal and even_k, fuse mask differently").
4. Document **negative results** (if any – not present in this single file, but note that we only see one configuration).
5. Update v3 → v4 DSL with all findings, preserving backward compatibility.

**Output artifacts**:
- `fmha_system_v4.dsl` – the evolved DSL.
- `insights_log.jsonl` – each extracted insight as a JSON object.
- `CLAUDE.md` – appended with new generalized patterns.
- (Optional) `report.md` – summary of what was discovered.

**Tool capabilities**:
- `cat <file>` – read file content.
- `python <script>` – run analysis scripts (you may write short Python to parse patterns).
- `llm query` – use the built-in LLM to analyze code, suggest DSL updates, etc.
- `write` – create/append files.
- `dsl_update` – (if available) a custom tool to patch DSL files; otherwise use `write` to overwrite with careful edits.

**Start by reading `attention.py` and `fmha_system_v3.dsl`. Then propose a step-by-step reverse engineering plan.**